# Alex and Ben make a shell with all these things

* [x] exit
* [x] which
* [ ] where
* [ ] cd
* [x] pwd
* [ ] list
* [ ] pid
* [ ] kill
* [ ] prompt
* [ ] printenv
* [ ] setenv

---

* [X] Obviously, you will need to do some parsing of the command line entered. A good way to do this would be to use `fgets(3)` to read in the (entire) command line, then use `strtok(3)` with a space as the delimiter. The first "word" will be the command (where we'll ignore the possibility that a command could have a space in its name). All the "words" after that will be arguments to be passed to the command (which you will need to put into a `char**`). Check out [parse-cmd.c](https://www.eecis.udel.edu/~cshen/361/PA_3_Simple_Shell/sample-code/parse-cmd.c) to see how this is done. `fgets()` returns NULL on error or when end of file (EOF) occurs while no characters have been read.
* [X] After you get the command, check if it is one of your built-in commands (explained below). If it is, then call the corresponding function for that.
* [ ] If it is not one of your built-in commands, check if it is an **absolute path** (a command begins with '`/`') or a path begins with '`./`', '`../`', etc., and run that if it is an executable (use `access(2)` to check).
* [ ] If the command is neither of the above cases then search for the command in the search path by looping through the paths stored as a **linked list** as given in `get_path.c` in the [skeleton code](https://www.eecis.udel.edu/~cshen/361/PA_3_Simple_Shell/skeleton-code). (You may `gcc get_path.c get_path_main.c` and run the generated `a.out` to see what happends.) You may also use your own linked list code. Use `access(2)` in a loop to find the first executable in the paths for the command. `snprintf(3)` would be useful to use here (as using `strcat()` has caused problems for some people).
* [ ] Once you find the (external) command you should execute it, using `execve(2)`. Review [execve_ls.c](https://www.eecis.udel.edu/~cshen/361/PA_3_Simple_Shell/sample-code/execve_ls.c) to see how `execve(2)` should be invoked. You also need to have the shell do a `waitpid(2)` and print out the return status of the command if it is nonzero like `tcsh` does when the `printexitvalue` shell variable is set. Look into using the WEXITSTATUS macro from [sys](http://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html).
* [ ] Before executing a command, your shell should also print out what it is about to execute. (i.e. print "Executing [*pathname*]"; for built-in commands, print "Executing built-in [*built-in command name*]").
* [ ] You need to support the `*` wildcard character when a single `*` is given. You do not need to handle the situation when `*` is given with a `/` in the string (i.e., /usr/include/*.h). This should work just like it does in csh/tcsh when `noglob` is not set. You need only to support the possibility of one `*` on your command line, but it could have characters prepended and/or appended. (That is, `ls *` should work correctly as should `ls *.c`, `ls s*`, `ls p*.txt`, etc.) Hint: implement the `list` built-in command explained below before attempting this. You may use `glob(3)` or `wordexp(3)`if you wish. [Review `glob.c` in [sample code](https://www.eecis.udel.edu/~cshen/361/PA_3_Simple_Shell/sample-code).] Note that it is YOUR shell's responsibility to expand wildcards to matching (file) names. (Review `wildcard-1.c` in [sample code](https://www.eecis.udel.edu/~cshen/361/PA_3_Simple_Shell/sample-code).) If there were no matches, the "original" arguments are passed to `execve()`. You would only need to make the wildcard to work with external commands.
* [ ] Ctrl-C (SIGINT) should be caught and ignored if the shell is prompting for a command, but sent to the running child process otherwise. Use `signal(2)` and/or `sigset(3)` for this. Ctrl-Z (SIGTSTP) and SIGTERM should be ignored using `sigignore(3)` or `signal(3)`. Note that when you are running a command inside your shell and press control-C, signal SIGINT is sent to both your shell process and the running command process (i.e., all the processes in the *foreground* process group). (Review Sections 9.4 (Process Groups), 9.5 (Sessions), and 9.6 (Controlling Terminal) of Stevens and Rago's [APUE book](http://proquestcombo.safaribooksonline.com/book/programming/unix/9780321638014) for details.)
* [ ] Your shell should treat Ctrl-D and the [EOF](http://www.computerhope.com/jargon/e/eof.htm) char in a similar way csh/tcsh do when the `ignoreeof` [tcsh shell variable](http://www.ibm.com/developerworks/aix/library/au-tcsh/) is set, i.e., ignore it, instead of exiting or seg faulting. Note that Ctrl-D is not a signal, but the EOF char. If `ignoreeof` is set to the empty string or `0' and the input device is a terminal, the end-of-file command (usually generated by the user by typing `^D' on an empty line) causes the shell to print `Use "exit" to leave tcsh.' instead of exiting. This prevents the shell from accidentally being killed. If set to a number n, the shell ignores n - 1 consecutive end-of-files and exits on the nth. If unset, `1' is used, i.e. the shell exits on a single `^D'. Review all the [shell variables of tcsh](https://nature.berkeley.edu/~casterln/tcsh/Special_shell_variables.html). (Please review the ***difference*** between [Shell Variables and Environment Variables](https://askubuntu.com/questions/26318/environment-variable-vs-shell-variable-whats-the-difference).) You may also review [this code](https://www.eecis.udel.edu/~cshen/361/PA_3_Simple_Shell/sample-code/fgets_ctrl_D.c) to see how `fgets()` works with EOF.
* [ ] Your code should do proper error checking. Again, check man pages for error conditions, and call `perror(3)` as needed. Also avoid memory leaks by calling `free(3)` as needed.
